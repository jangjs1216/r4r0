# Architecture Bible (for AI-assisted Coding)

이 문서는 이 레포지토리 전체에 적용되는 **아키텍처/코딩/문서화 원칙**이다.  
모든 변경 사항(코드 생성·수정·리팩터링·문서화)은 반드시 아래 원칙을 **우선적으로** 따른다.

---

## 1. 목표 (GOAL)

1. 각 기능 단위를 **작은 마이크로서비스**로 나눈다.
2. 화면(View)마다 **자기 책임을 가진 독립 서비스**로 구현한다.
3. 여러 View를 묶는 **오케스트레이션조차 하나의 마이크로서비스**로 구현한다.
4. 바이브 코딩을 하더라도:
   - 서비스 경계가 무너지지 않고,
   - 구조가 비대해지지 않고,
   - 계약(Contract)이 깨지지 않도록 한다.
5. **AI의 코드 산출 속도에 사람이 이해·검증 속도로 따라갈 수 있도록**,  
   각 마이크로서비스별로 **요구사항·계약 위주의 ServiceSpec.md**를 유지한다.
   - 문서는 “코드 미러링”이 아니라 **고수준 모델/계약/플로우의 미러링**만 수행한다.

---

## 2. 전체 아키텍처 개요

- **각 View = 하나의 마이크로서비스**
  - 예: `OrderListViewService`, `StockChartViewService`, `UserProfileViewService` 등
  - 각 View Service는 **자기 화면/도메인에 필요한 로직만** 가진다.
- **Orchestrator Service**
  - 여러 View Service를 **순서·조건·데이터 흐름** 관점에서 묶어 주는 서비스
  - View 내부 구현을 알지 않고, **공개된 계약(API/이벤트)** 만 사용한다.
- **서비스 간 통신**
  - 서비스 간 상호작용은 **API 호출 또는 메시지/이벤트**를 통해서만 한다.
  - **다른 서비스의 DB/내부 구현에 직접 접근하면 안 된다.**

---

## 3. 마이크로서비스 종류와 역할

### 3.1 View Service

**역할**

- 특정 화면/패널/위젯에 대한:
  - 데이터 조회/변환
  - 해당 View 전용 도메인 로직
- 외부에 제공하는 것은:
  - 명확히 정의된 **입력 파라미터**
  - 명확한 **출력 DTO/JSON**

**View Service가 해서는 안 되는 일**

- 다른 View Service의 DB/내부 객체에 직접 접근
- 화면 전체의 플로우/시나리오를 관리
- 여러 View를 동시에 조합하는 오케스트레이션

---

### 3.2 Orchestrator Service

**역할**

- 여러 View Service를 **조합, 순서 제어, 조건 분기**하는 역할
- 예:
  - `UserView` 결과를 받아 `OrderListView`에 필터로 넘김
  - 특정 이벤트 발생 시 `NotificationView`를 호출

**Orchestrator가 해서는 안 되는 일**

- 개별 View의 상세 도메인 규칙을 재구현
- 개별 View의 DB를 직접 조회
- 복잡한 비즈니스 로직을 Orchestrator에 쌓아 올리는 것  
  (비즈니스 규칙은 가능한 View Service 내부에 둔다)

---

## 4. 서비스 간 계약 (Contract)

모든 마이크로서비스는 **명시적인 계약(Contract)** 을 가진다.

1. **계약 구성 요소**
   - 엔드포인트/메서드 명
   - 입력 파라미터 구조 (DTO/JSON 스키마)
   - 출력 데이터 구조 (DTO/JSON 스키마)
   - 오류 코드/에러 응답 형식

2. **계약 원칙**
   - Orchestrator와 다른 서비스는 **계약에만 의존**한다.
   - 계약을 변경해야 하는 경우:
     - 가능한 한 **새 버전(예: `v2`) 추가**를 우선 고려한다.
     - 기존 계약을 깨는 변경(브레이킹 체인지)은 **최소화**한다.

3. **AI를 위한 지침**
   - 특정 서비스를 수정할 때:
     - 그 서비스의 계약 정의를 먼저 확인한다.
     - **계약(입력/출력 형식)을 함부로 변경하지 않는다.**
   - 계약을 수정해야 한다고 판단되면:
     - “어떤 계약을 왜 바꿔야 하는지”를 먼저 명시하고,
     - 가능한 **하위 호환 방식**을 우선 제안한다.

---

## 5. 각 마이크로서비스 내부 구조 원칙

언어/프레임워크와 상관없이, 각 서비스는 아래와 같은 **단순한 레이어 구조**를 따른다.

- `API Layer`  
  - HTTP/gRPC Controller, Handler, Router 등
  - 요청/응답 매핑만 담당 (DTO <-> 내부 모델 변환)
- `Application Layer`  
  - 유스케이스/시나리오 단위 서비스
  - 트랜잭션 경계, 여러 도메인 객체 조합
- `Domain Layer`  
  - Entity, Value Object, Domain Service 등
  - 순수 비즈니스 로직, **외부 라이브러리 의존 최소화**
- `Infrastructure Layer`  
  - DB, 메시지 브로커, 외부 API 클라이언트, 파일 I/O 등

**의존 방향 규칙**

- `API` → `Application` → `Domain`  
- `Infrastructure`는 위 레이어에 **주입되는 구현체**로 사용된다.
- 도메인 코드는 `HttpClient`, `DbContext`, 프레임워크 API 등을 직접 사용하지 않는다.

**금지 패턴**

- 이유 없이 새로운 레이어 타입 추가 (`*Manager`, `*Helper`, `*Util` 등을 남발)
- 단순 pass-through만 하는 계층을 여러 겹 추가하는 것
- 한 클래스/서비스에 너무 많은 책임을 몰아 넣는 God Object

---

## 6. 변경 원칙 (코드 생성·수정·리팩터링 시)

AI가 코드를 생성·수정할 때 **반드시 지켜야 할 규칙**이다.

1. **한 번에 하나의 서비스만 다룬다.**
   - 한 요청(프롬프트)에서 여러 마이크로서비스를 동시에 크게 바꾸지 않는다.
   - 어떤 서비스를 수정하는지 명확히 지정한다.
     - 예: “이번 변경은 `OrderListViewService`만 대상으로 한다.”

2. **계약 우선**
   - 먼저 그 서비스의 **공개 계약(Contract)** 을 확인한다.
   - 계약을 유지한 채로 요구사항을 만족시킬 수 있는지 우선 검토한다.
   - 계약 변경이 필요하면:
     - 변경 이유와 영향 범위를 설명하고
     - 하위 호환 방식(새 필드 추가, 새 버전 엔드포인트 등)을 우선 제안한다.

3. **기존 구조를 존중**
   - 이미 존재하는 레이어 구조와 책임 범위를 가능한 그대로 유지한다.
   - 새 클래스를 만들기 전에:
     - 기존 클래스의 책임을 조금 확장하는 것이 더 적절한지 먼저 검토한다.
   - 새로운 Manager/Helper/Util 클래스를 생성하는 것은 **최후의 수단**이다.

4. **변경 범위 최소화**
   - 요구사항을 만족시키는 **최소한의 수정**을 목표로 한다.
   - 불필요하게 많은 파일/라인을 수정하지 않는다.
   - 리팩터링이 필요하면:
     - 기능 추가와 섞지 말고,
     - “리팩터링 전용 변경”으로 분리하는 것을 우선 고려한다.

5. **테스트와 검증**
   - 도메인/애플리케이션 로직에 변경이 있을 경우:
     - 가능한 한 **테스트 코드(단위/통합 테스트)** 를 함께 수정 또는 추가한다.
   - 계약(Contract)에 관련된 변경이 있을 경우:
     - 계약 테스트(Contract Test) 또는 API 테스트를 함께 갱신한다.

---

## 7. ServiceSpec.md 규칙 (마이크로서비스별 요구사항·계약 미러링)

각 마이크로서비스는 루트 혹은 명확한 위치에 **자기 전용 스펙 문서**를 가진다.  
파일 이름 예시:

- `services/OrderListViewService/ServiceSpec.md`
- `services/InventoryService/ServiceSpec.md`
- `services/Orchestrator/ServiceSpec.md`

이 문서는 **“코드의 상세 구현”이 아니라, 다음 4가지를 위한 요약본**이다.

1. 사람에게:
   - 이 서비스의 역할/계약/모델/플로우를 **빠르게 이해**시키기 위해
2. AI에게:
   - **컨텍스트를 압축**해서 제공하기 위해
   - 코드 전체 대신 ServiceSpec + 일부 코드만으로도 일관성 있는 변경을 하기 위해

### 7.1 ServiceSpec.md에 포함해야 할 내용

ServiceSpec.md는 가능하면 아래 구조를 따른다.  
(필요 시 섹션을 추가·축소할 수 있으나, **불필요하게 길게 작성하지 않는다.**)


# <ServiceName> - Service Spec

## 1. 역할과 책임 (Responsibility)

- 이 서비스가 하는 일
- 이 서비스가 **하지 않는 일** (명시적으로 제외)

## 2. 외부 계약 (Contract)

### 2.1 REST / gRPC / Event

- 엔드포인트/메서드/토픽 정의
- 입력 파라미터 (필수/옵션, 타입, 제약조건)
- 응답 구조 (성공/에러)

### 2.2 사용 예 (Examples)

- 대표적인 호출 예시 1~2개

---

## 3. 내부 개념 모델 (Domain Model)

- 주요 도메인 타입/엔티티/Value Object
- 중요한 불변 조건(Invariants) 목록
  - 예: `amount >= 0`, `status`는 특정 enum만 허용 등

---

## 4. 주요 플로우 요약

- 핵심 유스케이스(시나리오) 1~3개를 단계별로 기술
  - 예: “주문 목록 조회 플로우”, “재고 차감 플로우” 등
- 구현 디테일이 아니라 **데이터 흐름/의사결정 흐름** 수준으로만 기술

---

## 5. 변경 이력 (Change Log)

- 날짜 / 변경 요약 (한 줄씩)
  - `2025-12-16: 초기 정의`
  - `2025-12-20: status 필터 추가`

### 7.2 ServiceSpec.md에 **절대 넣지 말 것**

- 함수/클래스/메서드의 **라인 단위 설명**
- 내부 구현을 그대로 풀어쓴 **자연어 번역본**
- 코드와 1:1로 매핑되는 상세 구현 정보

> ServiceSpec.md는 **“요구사항·계약·모델 수준의 미러링”** 문서이지,  
> 코드의 자연어 복붙본이 아니다.

---

### 7.3 AI를 위한 ServiceSpec 사용 원칙

AI는 특정 서비스를 다룰 때, 다음 순서를 따른다.

1. **ServiceSpec 우선**
   - 항상 해당 서비스의 `ServiceSpec.md`를 먼저 읽고,  
     그 내용을 **이 변경의 기준 진실(single source of truth)** 로 사용한다.
   - 스펙에 맞지 않는 구현이 발견되면:
     - 스펙이 잘못됐는지, 구현이 잘못됐는지 먼저 판단한다.

2. **Spec → 코드 순서**
   - 서비스의 요구사항/계약/플로우에 변경이 필요하다면,
     - 먼저 `ServiceSpec.md`의 변경 사항(추가·수정·삭제)을 제안한다.
   - 그 다음, 스펙에 맞춰 실제 코드를 생성·수정한다.

3. **Spec와 코드의 동기화**
   - 스펙에 반영된 변경이 코드에도 반영되었는지 확인한다.
   - 코드 수준에서 의미 있는 기능 변경이 있었는데도 스펙이 영향을 받는다면,
     - 반드시 `ServiceSpec.md`의 플로우/계약/모델을 함께 업데이트한다.

4. **Spec는 간결하게 유지**
   - 불필요한 예시나 장황한 설명으로 문서를 길게 만들지 않는다.
   - 문서가 너무 길어져 컨텍스트 비용이 커지지 않도록,
     - 요구사항·계약·모델·주요 플로우에만 집중한다.

---

## 8. AI 컨텍스트 운용 규칙 (Prompting Strategy)

AI가 가장 효율적으로 컨텍스트를 운용하고,  
사람이 AI의 산출물을 따라갈 수 있도록 하기 위해,  
다음 원칙에 따라 프롬프트를 구성한다.

1. **항상 포함해야 할 것**
   - 이 `Bible.md` (또는 최소한 관련 섹션 요약본)
   - 타깃 마이크로서비스의 `ServiceSpec.md`
   - 이번 변경에서 수정 가능한 파일 목록 및 해당 코드 일부

2. **포함하지 말아야 할 것**
   - 현재 변경과 직접 관련 없는 다른 서비스의 전체 코드/문서
   - 불필요한 로그, 대량의 샘플 데이터 등

3. **작업 단위(Granularity)를 작게 유지**
   - “이번 요청에서는 이 서비스의 이 유스케이스만 수정한다”라는 식으로 범위를 한정한다.
   - 한 번의 요청에서:
     - 수정 파일 수, diff 라인 수, 새 파일 수를 가능한 작게 유지한다.

4. **Spec → 코드 → 요약의 3단계 루프**
   - (1) Spec 변경 제안  
   - (2) Spec 승인(또는 확정)을 전제로 코드 생성·수정  
   - (3) 마지막에 “이번 변경에서 무엇이 어떻게 바뀌었는지”를 요약  
   → 사람은 Spec diff + 변경 요약만 보고도 전체 구조를 따라갈 수 있어야 한다.

---

## 9. AI를 위한 체크리스트 (반드시 스스로 점검)

코드를 제안하거나 문서를 수정하기 전에, 아래 질문들에 대해 **모두 YES**가 되어야 한다.

### 9.1 서비스 경계

- [ ] 지금 수정하는 코드는 **어느 마이크로서비스**에 속하는지 명확한가?
- [ ] 다른 서비스의 DB 또는 내부 구현에 직접 접근하지 않았는가?

### 9.2 ServiceSpec 및 계약

- [ ] 이 서비스의 `ServiceSpec.md`를 먼저 읽고 이해했는가?
- [ ] ServiceSpec에 정의된 역할/책임/계약/플로우와 충돌하지 않는가?
- [ ] 서비스의 요구사항/계약/플로우가 변경되었다면, `ServiceSpec.md`도 함께 변경했는가?
- [ ] 이 서비스의 공개 계약(입력/출력/엔드포인트)을 확인했는가?
- [ ] 계약을 깨지 않고 요구사항을 구현하려고 시도했는가?
- [ ] 계약을 바꿨다면, 그 이유와 영향 범위를 설명했는가?

### 9.3 구조

- [ ] API / Application / Domain / Infrastructure 레이어 책임을 지켰는가?
- [ ] 새 레이어 타입이나 의미 없는 Manager/Helper/Util을 만들지 않았는가?
- [ ] 한 클래스/함수에 너무 많은 책임을 몰아넣지 않았는가?

### 9.4 변경 범위

- [ ] 요구사항을 만족시키는 최소한의 파일/라인만 수정했는가?
- [ ] 기능 추가와 큰 리팩터링을 한 번에 섞지 않았는가?

### 9.5 테스트

- [ ] 중요한 로직 변경에 대해 테스트를 추가하거나 수정했는가?
- [ ] 계약/API 변경이 있다면 그에 맞는 테스트를 갱신했는가?

---

## 10. 요약 문장 (AI가 항상 기억해야 할 것)

> - **각 View는 하나의 마이크로서비스다.**  
> - **View들을 엮는 것도 또 하나의 마이크로서비스다.**  
> - **서비스끼리는 계약으로만 이야기한다.**  
> - **각 서비스는 ServiceSpec.md로 요구사항·계약·모델·주요 플로우를 요약해 둔다.**  
> - **AI는 ServiceSpec를 기준 진실로 사용하고, 계약과 서비스 경계를 깨지 않는 선에서 최소한의 코드만 수정한다.**
```markdown