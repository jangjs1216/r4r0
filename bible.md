# Architecture Bible (for AI-assisted Coding)

> 이 문서는 모든 작업의 **항상 유지해야 할 컨텍스트**이며, 이후 요청/변경 시에도 최우선으로 참조해야 한다. (지금 읽은 내용을 대화·작업 내내 기억할 것)

이 문서는 이 레포지토리 전체에 적용되는 **아키텍처/코딩 원칙**이다.  
모든 변경 사항(코드 생성·수정·리팩터링)은 반드시 아래 원칙을 **우선적으로** 따른다.

---

## 1. 목표 (GOAL)

1. 각 기능 단위를 **작은 마이크로서비스**로 나눈다.
2. 화면(View)마다 **자기 책임을 가진 독립 서비스**로 구현한다.
3. 여러 View를 묶는 **오케스트레이션조차 하나의 마이크로서비스**로 구현한다.
4. 바이브 코딩을 하더라도:
   - 서비스 경계가 무너지지 않고,
   - 구조가 비대해지지 않고,
   - 계약(Contract)이 깨지지 않도록 한다.

---

## 2. 전체 아키텍처 개요

- **각 View = 하나의 마이크로서비스**
  - 예: `OrderListViewService`, `StockChartViewService`, `UserProfileViewService` 등
  - 각 View Service는 **자기 화면/도메인에 필요한 로직만** 가진다.
- **Orchestrator Service**
  - 여러 View Service를 **순서·조건·데이터 흐름** 관점에서 묶어 주는 서비스
  - View 내부 구현을 알지 않고, **공개된 계약(API)** 만 사용한다.
- **서비스 간 통신**
  - 서비스 간 상호작용은 **API 호출 또는 메시지/이벤트**를 통해서만 한다.
  - **다른 서비스의 DB/내부 구현에 직접 접근하면 안 된다.**

---

## 3. 마이크로서비스 종류와 역할

### 3.1 View Service

**역할**

- 특정 화면/패널/위젯에 대한:
  - 데이터 조회/변환
  - 해당 View 전용 도메인 로직
- 외부에 제공하는 것은:
  - 명확히 정의된 **입력 파라미터**
  - 명확한 **출력 DTO/JSON**

**View Service가 해서는 안 되는 일**

- 다른 View Service의 DB/내부 객체에 직접 접근
- 화면 전체의 플로우/시나리오를 관리
- 여러 View를 동시에 조합하는 오케스트레이션

---

### 3.2 Orchestrator Service

**역할**

- 여러 View Service를 **조합, 순서 제어, 조건 분기**하는 역할
- 예:
  - `UserView` 결과를 받아 `OrderListView`에 필터로 넘김
  - 특정 이벤트 발생 시 `NotificationView`를 호출

**Orchestrator가 해서는 안 되는 일**

- 개별 View의 상세 도메인 규칙을 재구현
- 개별 View의 DB를 직접 조회
- 복잡한 비즈니스 로직을 Orchestrator에 쌓아 올리는 것  
  (비즈니스 규칙은 가능한 View Service 내부에 둔다)

---

## 4. 서비스 간 계약 (Contract)

모든 마이크로서비스는 **명시적인 계약(Contract)** 을 가진다.

1. **계약 구성 요소**
   - 엔드포인트/메서드 명
   - 입력 파라미터 구조 (DTO/JSON 스키마)
   - 출력 데이터 구조 (DTO/JSON 스키마)
   - 오류 코드/에러 응답 형식

2. **계약 원칙**
   - Orchestrator와 다른 서비스는 **계약에만 의존**한다.
   - 계약을 변경해야 하는 경우:
     - 가능한 한 **새 버전(예: `v2`) 추가**를 우선 고려한다.
     - 기존 계약을 깨는 변경(브레이킹 체인지)은 **최소화**한다.

3. **AI를 위한 지침**
   - 특정 서비스를 수정할 때:
     - 그 서비스의 계약 정의를 먼저 확인한다.
     - **계약(입력/출력 형식)을 함부로 변경하지 않는다.**
   - 계약을 수정해야 한다고 판단되면:
     - “어떤 계약을 왜 바꿔야 하는지”를 먼저 명시하고,
     - 가능한 **하위 호환 방식**을 우선 제안한다.

---

## 5. 각 마이크로서비스 내부 구조 원칙

언어/프레임워크와 상관없이, 각 서비스는 아래와 같은 **단순한 레이어 구조**를 따른다.

- `API Layer`  
  - HTTP/gRPC Controller, Handler, Router 등
  - 요청/응답 매핑만 담당 (DTO <-> 내부 모델 변환)
- `Application Layer`  
  - 유스케이스/시나리오 단위 서비스
  - 트랜잭션 경계, 여러 도메인 객체 조합
- `Domain Layer`  
  - Entity, Value Object, Domain Service 등
  - 순수 비즈니스 로직, **외부 라이브러리 의존 최소화**
- `Infrastructure Layer`  
  - DB, 메시지 브로커, 외부 API 클라이언트, 파일 I/O 등

**의존 방향 규칙**

- `API` → `Application` → `Domain`  
- `Infrastructure`는 위 레이어에 **주입되는 구현체**로 사용된다.
- 도메인 코드는 `HttpClient`, `DbContext`, 프레임워크 API 등을 직접 사용하지 않는다.

**금지 패턴**

- 이유 없이 새로운 레이어 타입 추가 (`*Manager`, `*Helper`, `*Util` 등을 남발)
- 단순 pass-through만 하는 계층을 여러 겹 추가하는 것
- 한 클래스/서비스에 너무 많은 책임을 몰아 넣는 God Object

---

## 6. 변경 원칙 (코드 생성·수정·리팩터링 시)

AI가 코드를 생성·수정할 때 **반드시 지켜야 할 규칙**이다.

1. **한 번에 하나의 서비스만 다룬다.**
   - 한 요청(프롬프트)에서 여러 마이크로서비스를 동시에 크게 바꾸지 않는다.
   - 어떤 서비스를 수정하는지 명확히 지정한다.
     - 예: “이번 변경은 `OrderListViewService`만 대상으로 한다.”

2. **계약 우선**
   - 먼저 그 서비스의 **공개 계약(Contract)** 을 확인한다.
   - 계약을 유지한 채로 요구사항을 만족시킬 수 있는지 우선 검토한다.
   - 계약 변경이 필요하면:
     - 변경 이유와 영향 범위를 설명하고
     - 하위 호환 방식(새 필드 추가, 새 버전 엔드포인트 등)을 우선 제안한다.

3. **기존 구조를 존중**
   - 이미 존재하는 레이어 구조와 책임 범위를 가능한 그대로 유지한다.
   - 새 클래스를 만들기 전에:
     - 기존 클래스의 책임을 조금 확장하는 것이 더 적절한지 먼저 검토한다.
   - 새로운 Manager/Helper/Util 클래스를 생성하는 것은 **최후의 수단**이다.

4. **변경 범위 최소화**
   - 요구사항을 만족시키는 **최소한의 수정**을 목표로 한다.
   - 불필요하게 많은 파일/라인을 수정하지 않는다.
   - 리팩터링이 필요하면:
     - 기능 추가와 섞지 말고,
     - “리팩터링 전용 변경”으로 분리하는 것을 우선 고려한다.

5. **테스트와 검증**
   - 도메인/애플리케이션 로직에 변경이 있을 경우:
     - 가능한 한 **테스트 코드(단위/통합 테스트)** 를 함께 수정 또는 추가한다.
   - 계약(Contract)에 관련된 변경이 있을 경우:
     - 계약 테스트(Contract Test) 또는 API 테스트를 함께 갱신한다.

---

## 7. AI를 위한 체크리스트 (반드시 스스로 점검)

코드를 제안하기 전에, 아래 질문들에 대해 **모두 YES**가 되어야 한다.

1. **서비스 경계**
   - [ ] 지금 수정하는 코드는 **어느 마이크로서비스**에 속하는지 명확한가?
   - [ ] 다른 서비스의 DB 또는 내부 구현에 직접 접근하지 않았는가?

2. **계약**
   - [ ] 이 서비스의 공개 계약(입력/출력/엔드포인트)을 먼저 확인했는가?
   - [ ] 계약을 깨지 않고 요구사항을 구현하려고 시도했는가?
   - [ ] 계약을 바꿨다면, 그 이유와 영향 범위를 설명했는가?

3. **구조**
   - [ ] API / Application / Domain / Infrastructure 레이어 책임을 지켰는가?
   - [ ] 새 레이어 타입이나 의미 없는 Manager/Helper/Util을 만들지 않았는가?
   - [ ] 한 클래스/함수에 너무 많은 책임을 몰아넣지 않았는가?

4. **변경 범위**
   - [ ] 요구사항을 만족시키는 최소한의 파일/라인만 수정했는가?
   - [ ] 기능 추가와 큰 리팩터링을 한 번에 섞지 않았는가?

5. **테스트**
   - [ ] 중요한 로직 변경에 대해 테스트를 추가하거나 수정했는가?
   - [ ] 계약/API 변경이 있다면 그에 맞는 테스트를 갱신했는가?

---

## 8. 요약 문장 (AI가 항상 기억해야 할 것)

> - **각 View는 하나의 마이크로서비스다.**  
> - **View들을 엮는 것도 또 하나의 마이크로서비스다.**  
> - **서비스끼리는 계약으로만 이야기한다.**  
> - **계약과 서비스 경계를 깨지 않는 선에서, 최소한의 코드만 수정한다.**
